<!--- PUBLIC MODEL INITIALIZATION METHODS --->

<cffunction name="property" returntype="void" access="public" output="false" hint="Use this method to map an object property to either a table column with a different name than the property or to a SQL expression. You only need to use this method when you want to override the default object relational mapping that Wheels performs."
	examples=
	'
		<!--- Tell Wheels that when we are referring to `firstName` in the CFML code, it should translate to the `STR_USERS_FNAME` column when interacting with the database instead of the default (which would be the `firstname` column) --->
		<cfset property(name="firstName", column="STR_USERS_FNAME")>

		<!--- Tell Wheels that when we are referring to `fullName` in the CFML code, it should concatenate the `STR_USERS_FNAME` and `STR_USERS_LNAME` columns --->
		<cfset property(name="fullName", sql="STR_USERS_FNAME + '' '' + STR_USERS_LNAME")>

		<!--- Tell Wheels that when displaying error messages or labels for form fields, we want to use `First name(s)` as the label for the `STR_USERS_FNAME` column --->
		<cfset property(name="firstName", label="First name(s)")>

		<!--- Tell Wheels that when creating new objects, we want them to be auto-populated with a `firstName` property of value `Dave` --->
		<cfset property(name="firstName", defaultValue="Dave")>
	'
	categories="model-initialization,miscellaneous" chapters="object-relational-mapping" functions="columnNames,dataSource,propertyNames,table,tableName">
	<cfargument name="name" type="string" required="true" hint="The name that you want to use for the column or SQL function result in the CFML code.">
	<cfargument name="column" type="string" required="false" default="" hint="The name of the column in the database table to map the property to.">
	<cfargument name="sql" type="string" required="false" default="" hint="A SQL expression to use to calculate the property value.">
	<cfargument name="label" type="string" required="false" default="" hint="A custom label for this property to be referenced in the interface and error messages.">
	<cfargument name="defaultValue" type="any" required="false" hint="A default value for this property.">
	<cfscript>
		// validate setup
		if (Len(arguments.column) and Len(arguments.sql))
			$throw(type="Wheels", message="Incorrect Arguments", extendedInfo="You cannot specify both a column and a sql statement when setting up the mapping for this property.");
		if (Len(arguments.sql) and StructKeyExists(arguments, "defaultValue"))
			$throw(type="Wheels", message="Incorrect Arguments", extendedInfo="You cannot specify a default value for calculated properties.");

		// create the key
		if (!StructKeyExists(variables.wheels.class.mapping, arguments.name))
			variables.wheels.class.mapping[arguments.name] = {};

		if (Len(arguments.column))
		{
			variables.wheels.class.mapping[arguments.name].type = "column";
			variables.wheels.class.mapping[arguments.name].value = arguments.column;
		}

		if (Len(arguments.sql))
		{
			variables.wheels.class.mapping[arguments.name].type = "sql";
			variables.wheels.class.mapping[arguments.name].value = arguments.sql;
		}

		if (Len(arguments.label))
			variables.wheels.class.mapping[arguments.name].label = arguments.label;

		if (StructKeyExists(arguments, "defaultValue"))
			variables.wheels.class.mapping[arguments.name].defaultValue = arguments.defaultValue;
	</cfscript>
</cffunction>

<!--- PUBLIC MODEL CLASS METHODS --->

<cffunction name="propertyNames" returntype="string" access="public" output="false" hint="Returns a list of property names ordered by their respective column's ordinal position in the database table. Also includes calculated property names that will be generated by the Wheels ORM."
	examples=
	'
		<!--- Get a list of the property names in use in the user model --->
  		<cfset propNames = model("user").propertyNames()>
	'
	categories="model-class,miscellaneous" chapters="object-relational-mapping" functions="columnNames,dataSource,property,table,tableName">
	<cfscript>
		var loc = {};
		loc.returnValue = super.propertyNames();
		if (ListLen(variables.wheels.class.calculatedPropertyList))
		{
			loc.returnValue = ListAppend(loc.returnValue, variables.wheels.class.calculatedPropertyList);
		}
	</cfscript>
	<cfreturn loc.returnValue>
</cffunction>

<cffunction name="columns" returntype="array" access="public" output="false" hint="Returns an array of columns names for the table associated with this class. Does not include calculated properties that will be generated by the Wheels ORM."
	examples=
	'
		<!--- Get the columns names in the order they are in the database --->
		<cfset employee = model("employee").columns()>
	'
	categories="model-class,miscellaneous" chapters="object-relational-mapping" functions="">
	<cfreturn ListToArray(variables.wheels.class.columnList) />
</cffunction>

<cffunction name="columnForProperty" returntype="any" access="public" output="false" hint="Returns the column name mapped for the named model property."
	examples=
	'
		<!--- Get an object, set a value and then see if the property exists --->
		<cfset employee = model("employee").new()>
		<cfset employee.columnForProperty("firstName")><!--- returns column name, in this case "firstname" if the convention is used --->
	'
	categories="model-class,miscellaneous" chapters="object-relational-mapping" functions="">
	<cfargument name="property" type="string" required="true" hint="@hasProperty." />
	<cfscript>
		var columnName = false;
		if (StructKeyExists(variables.wheels.class.properties, arguments.property))
			columnName = variables.wheels.class.properties[arguments.property].column;
	</cfscript>
	<cfreturn columnName />
</cffunction>

<cffunction name="columnDataForProperty" returntype="any" access="public" output="false" hint="Returns a struct with data for the named property."
	examples=
	'
		<!--- Get an object, set a value and then see if the property exists --->
		<cfset employee = model("employee").new()>
		<cfset employee.columnDataForProperty("firstName")><!--- returns column struct --->
	'
	categories="model-class,miscellaneous" chapters="object-relational-mapping" functions="">
	<cfargument name="property" type="string" required="true" hint="Name of column to retrieve data for." />
	<cfscript>
		var columnData = false;
		if (StructKeyExists(variables.wheels.class.properties, arguments.property))
			columnData = variables.wheels.class.properties[arguments.property];
	</cfscript>
	<cfreturn columnData />
</cffunction>

<cffunction name="validationTypeForProperty" returntype="any" access="public" output="false" hint="Returns the validation type for the property"
	examples=
	'
		<!--- first name is a varchar(50) column --->
		<cfset employee = model("employee").new()>
		<!--- would output "string" --->
		<cfoutput>##employee.validationTypeForProperty("firstName")>##</cfoutput>
	'
	categories="model-class,miscellaneous" chapters="object-relational-mapping" functions="">
	<cfargument name="property" type="string" required="true" hint="Name of column to retrieve data for." />
	<cfscript>
		var columnData = "string";
		if (StructKeyExists(variables.wheels.class.properties, arguments.property))
		{
			columnData = variables.wheels.class.properties[arguments.property].validationtype;
		}
	</cfscript>
	<cfreturn columnData />
</cffunction>

<!--- PUBLIC MODEL OBJECT METHODS --->

<cffunction name="key" returntype="string" access="public" output="false" hint="Returns the value of the primary key for the object. If you have a single primary key named `id`, then `someObject.key()` is functionally equivalent to `someObject.id`. This method is more useful when you do dynamic programming and don't know the name of the primary key or when you use composite keys (in which case it's convenient to use this method to get a list of both key values returned)."
	examples=
	'
		<!--- Get an object and then get the primary key value(s) --->
		<cfset employee = model("employee").findByKey(params.key)>
		<cfset val = employee.key()>
	'
	categories="model-object,miscellaneous" chapters="" functions="">
	<cfargument name="$persisted" type="boolean" required="false" default="false">
	<cfargument name="$returnTickCountWhenNew" type="boolean" required="false" default="false">
	<cfscript>
		var loc = {};
		loc.returnValue = "";
		loc.iEnd = ListLen(primaryKeys());
		for (loc.i=1; loc.i <= loc.iEnd; loc.i++)
		{
			loc.property = primaryKeys(loc.i);
			if (StructKeyExists(this, loc.property))
			{
				if (arguments.$persisted && hasChanged(loc.property))
					loc.returnValue = ListAppend(loc.returnValue, changedFrom(loc.property));
				else
					loc.returnValue = ListAppend(loc.returnValue, this[loc.property]);
			}
		}
		if (!Len(loc.returnValue) && arguments.$returnTickCountWhenNew)
			loc.returnValue = variables.wheels.instance.tickCountId;
		</cfscript>
	<cfreturn loc.returnValue>
</cffunction>

<cffunction name="toggle" returntype="any" access="public" output="false" hint="Assigns to the property specified the opposite of the property's current boolean value. Throws an error if the property cannot be converted to a boolean value. Returns this object if save called internally is `false`."
	examples=
	'
		<!--- Get an object, and toggle a boolean property --->
		<cfset user = model("user").findByKey(58)>
		<cfset isSuccess = user.toggle("isActive")><!--- returns whether the object was saved properly --->
		<!--- You can also use a dynamic helper for this --->
		<cfset isSuccess = user.toggleIsActive()>
	'
	categories="model-object,crud" chapters="updating-records" functions="">
	<cfargument name="property" type="string" required="true" />
	<cfargument name="save" type="boolean" required="false" hint="Argument to decide whether save the property after it has been toggled. Defaults to true." />
	<cfscript>
		$args(name="toggle", args=arguments);
		if (!StructKeyExists(this, arguments.property))
			$throw(type="Wheels.PropertyDoesNotExist", message="Property Does Not Exist", extendedInfo="You may only toggle a property that exists on this model.");
		if (!IsBoolean(this[arguments.property]))
			$throw(type="Wheels.PropertyIsIncorrectType", message="Incorrect Arguments", extendedInfo="You may only toggle a property that evaluates to the boolean value.");
		this[arguments.property] = !this[arguments.property];
		if (arguments.save)
			return updateProperty(property=arguments.property, value=this[arguments.property]);
	</cfscript>
	<cfreturn this />
</cffunction>

<!--- PRIVATE MODEL OBJECT METHODS --->

<cffunction name="$setProperty" returntype="void" access="public" output="false">
	<cfargument name="property" type="string" required="true" />
	<cfargument name="value" type="any" required="true" />
	<cfargument name="associations" type="struct" required="false" default="#variables.wheels.class.associations#" />
	<cfargument name="callbacks" type="boolean" required="false" default="true" />
	<cfscript>
		if (IsObject(arguments.value))
			this[arguments.property] = arguments.value;
		else if (IsStruct(arguments.value) && StructKeyExists(arguments.associations, arguments.property) && arguments.associations[arguments.property].nested.allow && ListFindNoCase("belongsTo,hasOne", arguments.associations[arguments.property].type))
			$setOneToOneAssociationProperty(property=arguments.property, value=arguments.value, association=arguments.associations[arguments.property], callbacks=arguments.callbacks);
		else if (IsStruct(arguments.value) && StructKeyExists(arguments.associations, arguments.property) && arguments.associations[arguments.property].nested.allow && arguments.associations[arguments.property].type == "hasMany")
			$setCollectionAssociationProperty(property=arguments.property, value=arguments.value, association=arguments.associations[arguments.property], callbacks=arguments.callbacks);
		else if (IsArray(arguments.value) && ArrayLen(arguments.value) && !IsObject(arguments.value[1]) && StructKeyExists(arguments.associations, arguments.property) && arguments.associations[arguments.property].nested.allow && arguments.associations[arguments.property].type == "hasMany")
			$setCollectionAssociationProperty(property=arguments.property, value=arguments.value, association=arguments.associations[arguments.property], callbacks=arguments.callbacks);
		else
			this[arguments.property] = arguments.value;
	</cfscript>
	<cfreturn />
</cffunction>

<cffunction name="$updatePersistedProperties" returntype="void" access="public" output="false">
	<cfscript>
		var loc = {};
		variables.$persistedProperties = {};
		for (loc.key in variables.wheels.class.properties)
			if (StructKeyExists(this, loc.key))
				variables.$persistedProperties[loc.key] = this[loc.key];
	</cfscript>
</cffunction>

<cffunction name="$label" returntype="string" access="public" output="false">
	<cfargument name="property" type="string" required="true">
	<cfargument name="properties" type="struct" required="false" default="#variables.wheels.class.properties#">
	<cfargument name="mapping" type="struct" required="false" default="#variables.wheels.class.mapping#">
	<cfscript>
		if (StructKeyExists(arguments.mapping, arguments.property) && StructKeyExists(arguments.mapping[arguments.property], "label"))
		{
			return arguments.mapping[arguments.property].label;
		}
		return super.$label(argumentCollection=arguments);
	</cfscript>
</cffunction>